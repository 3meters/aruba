package com.proxibase.aircandi.components;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.regex.Pattern;

import android.os.CountDownTimer;
import android.os.Debug;

public class Utilities {

	public static final Pattern	EMAIL_ADDRESS						= Pattern.compile(
																			"[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}" +
																					"\\@" +
																					"[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
																					"(" +
																					"\\." +
																					"[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
																					")+"
																			);
	/**
	 * Regular expression to match all IANA top-level domains for WEB_URL.
	 * List accurate as of 2010/02/05. List taken from:
	 * http://data.iana.org/TLD/tlds-alpha-by-domain.txt
	 * This pattern is auto-generated by frameworks/base/common/tools/make-iana-tld-pattern.py
	 */
	public static final String	TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL	= "(?:"
																			+ "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
																			+ "|(?:biz|b[abdefghijmnorstvwyz])"
																			+ "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
																			+ "|d[ejkmoz]"
																			+ "|(?:edu|e[cegrstu])"
																			+ "|f[ijkmor]"
																			+ "|(?:gov|g[abdefghilmnpqrstuwy])"
																			+ "|h[kmnrtu]"
																			+ "|(?:info|int|i[delmnoqrst])"
																			+ "|(?:jobs|j[emop])"
																			+ "|k[eghimnprwyz]"
																			+ "|l[abcikrstuvy]"
																			+ "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
																			+ "|(?:name|net|n[acefgilopruz])"
																			+ "|(?:org|om)"
																			+ "|(?:pro|p[aefghklmnrstwy])"
																			+ "|qa"
																			+ "|r[eosuw]"
																			+ "|s[abcdeghijklmnortuvyz]"
																			+ "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
																			+ "|u[agksyz]"
																			+ "|v[aceginu]"
																			+ "|w[fs]"
																			+ "|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a|xn\\-\\-deba0ad|xn\\-\\-g6w251d|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
																			+ "|y[etu]"
																			+ "|z[amw]))";
	public static final String	GOOD_IRI_CHAR						= "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";

	/**
	 * Regular expression pattern to match most part of RFC 3987
	 * Internationalized URLs, aka IRIs. Commonly used Unicode characters are
	 * added.
	 */
	public static final Pattern	WEB_URL								= Pattern
																			.compile("((?:(http|https|Http|Https|rtsp|Rtsp):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
																					+ "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
																					+ "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
																					+ "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
																					+ TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
																					+ "|(?:(?:25[0-5]|2[0-4]" // or ip address
																					+ "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
																					+ "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
																					+ "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
																					+ "|[1-9][0-9]|[0-9])))"
																					+ "(?:\\:\\d{1,5})?)" // plus option port number
																					+ "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
																					+ "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
																					+ "(?:\\b|$)");						// and finally, a word boundary or end of
																															// input.  This is to stop foo.sure from
																															// matching as foo.su

	public static class SimpleCountDownTimer extends CountDownTimer {

		private long	mMillisUntilFinished;

		public SimpleCountDownTimer(long millisInFuture) {
			this(millisInFuture, millisInFuture);
		}

		public SimpleCountDownTimer(long millisInFuture, long countDownInterval) {
			super(millisInFuture, countDownInterval);
			mMillisUntilFinished = millisInFuture;
		}

		@Override
		public void onFinish() {
			mMillisUntilFinished = 0;
		}

		@Override
		public void onTick(long millisUntilFinished) {
			mMillisUntilFinished = millisUntilFinished;
		}

		public long getMillisUntilFinished() {
			return mMillisUntilFinished;
		}
	}

	public static class Stopwatch {

		{
			Debug.startAllocCounting();
		}
		long	start	= System.nanoTime();

		void stop() {
			long elapsed = (System.nanoTime() - start) / 1000;
			Debug.stopAllocCounting();
			Logger.i(this, "CandiRadarActivity: " + elapsed + "us, "
					+ Debug.getThreadAllocCount() + " allocations, "
					+ Debug.getThreadAllocSize() + " bytes");
		}
	}

	/**
	 * Returns a copy of the object, or null if the object cannot be serialized.
	 */
	public static Object deepCopy(Object objectOriginal) {
		Object objectCopy = null;
		try {
			/*
			 * Write the object out to a byte array
			 */
			FastByteArrayOutputStream fbos = new Utilities.FastByteArrayOutputStream();
			ObjectOutputStream out = new ObjectOutputStream(fbos);
			out.writeObject(objectOriginal);
			out.flush();
			out.close();

			/*
			 * Make an input stream from the byte array and read a copy of the object back in.'
			 */
			ObjectInputStream in = new ObjectInputStream(fbos.getInputStream());
			objectCopy = in.readObject();
		}
		catch (IOException e) {
			e.printStackTrace();
		}
		catch (ClassNotFoundException cnfe) {
			cnfe.printStackTrace();
		}
		return objectCopy;
	}

	public static final String md5(final String s) {
		try {
			/* Create MD5 Hash */
			MessageDigest digest = java.security.MessageDigest.getInstance("MD5");
			digest.update(s.getBytes());
			byte messageDigest[] = digest.digest();

			/* Create Hex String */
			StringBuffer hexString = new StringBuffer();
			for (int i = 0; i < messageDigest.length; i++) {
				String h = Integer.toHexString(0xFF & messageDigest[i]);
				while (h.length() < 2) {
					h = "0" + h;
				}
				hexString.append(h);
			}
			return hexString.toString();

		}
		catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
		return "";
	}

	public static Boolean validEmail(String email) {
		return EMAIL_ADDRESS.matcher(email).matches();
	}

	public static Boolean validWebUri(String webUri) {
		return WEB_URL.matcher(webUri).matches();
	}

	/**
	 * ByteArrayOutputStream implementation that doesn't synchronize methods
	 * and doesn't copy the data on toByteArray().
	 */

	static public class FastByteArrayOutputStream extends OutputStream {
		/**
		 * Buffer and size
		 */
		protected byte[]	buf		= null;
		protected int		size	= 0;

		/**
		 * Constructs a stream with buffer capacity size 5K
		 */
		public FastByteArrayOutputStream() {
			this(5 * 1024);
		}

		/**
		 * Constructs a stream with the given initial size
		 */
		public FastByteArrayOutputStream(int initSize) {
			this.size = 0;
			this.buf = new byte[initSize];
		}

		/**
		 * Ensures that we have a large enough buffer for the given size.
		 */
		private void verifyBufferSize(int sz) {
			if (sz > buf.length) {
				byte[] old = buf;
				buf = new byte[Math.max(sz, 2 * buf.length)];
				System.arraycopy(old, 0, buf, 0, old.length);
				old = null;
			}
		}

		public int getSize() {
			return size;
		}

		/**
		 * Returns the byte array containing the written data. Note that this
		 * array will almost always be larger than the amount of data actually
		 * written.
		 */

		public byte[] getByteArray() {
			return buf;
		}

		public final void write(byte b[]) {
			verifyBufferSize(size + b.length);
			System.arraycopy(b, 0, buf, size, b.length);
			size += b.length;
		}

		public final void write(byte b[], int off, int len) {
			verifyBufferSize(size + len);
			System.arraycopy(b, off, buf, size, len);
			size += len;
		}

		public final void write(int b) {
			verifyBufferSize(size + 1);
			buf[size++] = (byte) b;
		}

		public void reset() {
			size = 0;
		}

		/**
		 * Returns a ByteArrayInputStream for reading back the written data
		 */
		public InputStream getInputStream() {
			return new FastByteArrayInputStream(buf, size);
		}

	}

	/**
	 * ByteArrayInputStream implementation that does not synchronize methods.
	 */

	static public class FastByteArrayInputStream extends InputStream {
		/**
		 * Our byte buffer
		 */
		protected byte[]	buf		= null;

		/**
		 * Number of bytes that we can read from the buffer
		 */
		protected int		count	= 0;

		/**
		 * Number of bytes that have been read from the buffer
		 */
		protected int		pos		= 0;

		public FastByteArrayInputStream(byte[] buf, int count) {
			this.buf = buf;
			this.count = count;
		}

		public final int available() {
			return count - pos;
		}

		public final int read() {
			return (pos < count) ? (buf[pos++] & 0xff) : -1;
		}

		public final int read(byte[] b, int off, int len) {
			if (pos >= count)
				return -1;

			if ((pos + len) > count)
				len = (count - pos);

			System.arraycopy(buf, pos, b, off, len);
			pos += len;
			return len;
		}

		public final long skip(long n) {
			if ((pos + n) > count)
				n = count - pos;
			if (n < 0)
				return 0;
			pos += n;
			return n;
		}

	}

}